
-- Enable required extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Create users table
CREATE TABLE IF NOT EXISTS public.users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email TEXT NOT NULL,
    first_name TEXT NOT NULL,
    last_name TEXT NOT NULL,
    phone TEXT,
    bio TEXT,
    industry TEXT,
    subject_matter TEXT,
    audience TEXT,
    usp TEXT,
    writing_style TEXT,
    keywords TEXT[],
    core_beliefs TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Create pr_sessions table
CREATE TABLE IF NOT EXISTS public.pr_sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    session_id TEXT NOT NULL,
    user_id UUID NOT NULL REFERENCES public.users(id),
    step SMALLINT NOT NULL DEFAULT 1,
    datetime TIMESTAMP WITH TIME ZONE DEFAULT now(),
    audience TEXT,
    subject_matter TEXT,
    usp TEXT,
    writing_style TEXT,
    gmail_threadid VARCHAR,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Create pr_articles table
CREATE TABLE IF NOT EXISTS public.pr_articles (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    session_id UUID NOT NULL REFERENCES public.pr_sessions(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    content TEXT NOT NULL,
    url TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'draft',
    confidence_score REAL,
    article_number SMALLINT,
    description TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Create pr_blogs table
CREATE TABLE IF NOT EXISTS public.pr_blogs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    article_id UUID NOT NULL REFERENCES public.pr_articles(id) ON DELETE CASCADE UNIQUE,
    title TEXT NOT NULL,
    content TEXT NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Create talking_point_types table
CREATE TABLE IF NOT EXISTS public.talking_point_types (
    id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    label TEXT NOT NULL
);

-- Create pr_talking_points table
CREATE TABLE IF NOT EXISTS public.pr_talking_points (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    article_id UUID NOT NULL REFERENCES public.pr_articles(id) ON DELETE CASCADE,
    talking_point_type_id INTEGER NOT NULL REFERENCES public.talking_point_types(id),
    content TEXT NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Create view for talking points with titles
CREATE OR REPLACE VIEW talking_points_with_titles AS
SELECT
    t.label,
    tp.article_id,
    tp.talking_point_type_id,
    tp.content
FROM pr_talking_points tp
JOIN talking_point_types t ON t.id = tp.talking_point_type_id;

-- Enable Row Level Security
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.pr_sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.pr_articles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.pr_blogs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.pr_talking_points ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.talking_point_types ENABLE ROW LEVEL SECURITY;

-- Add RLS Policies
CREATE POLICY "Customer can manage own profile"
ON public.users
FOR ALL
USING (auth.uid() = id)
WITH CHECK (auth.uid() = id);

CREATE POLICY "Admins can select users"
ON public.users
FOR SELECT USING (is_admin_or_superadmin());

-- PR Sessions policies
CREATE POLICY "Customer can see own pr sessions"
ON public.pr_sessions
FOR SELECT
USING (user_id = auth.uid());

CREATE POLICY "Admins can select sessions"
ON public.pr_sessions
FOR SELECT USING (is_admin_or_superadmin());

-- PR Articles policies
CREATE POLICY "Customer can manage articles related to their sessions"
ON public.pr_articles
FOR ALL
USING (
    EXISTS (
        SELECT 1
        FROM pr_sessions s
        WHERE s.id = pr_articles.session_id
        AND s.user_id = auth.uid()
    )
)
WITH CHECK (
    EXISTS (
        SELECT 1
        FROM pr_sessions s
        WHERE s.id = pr_articles.session_id
        AND s.user_id = auth.uid()
    )
);

-- PR Talking Points policies
CREATE POLICY "Customer can manage talking points related to their articles"
ON public.pr_talking_points
FOR ALL
USING (
    EXISTS (
        SELECT 1
        FROM pr_articles a
        JOIN pr_sessions s ON s.id = a.session_id
        WHERE a.id = pr_talking_points.article_id
        AND s.user_id = auth.uid()
    )
)
WITH CHECK (
    EXISTS (
        SELECT 1
        FROM pr_articles a
        JOIN pr_sessions s ON s.id = a.session_id
        WHERE a.id = pr_talking_points.article_id
        AND s.user_id = auth.uid()
    )
);

-- PR Blogs policies
CREATE POLICY "Customers can manage blogs related to their articles"
ON public.pr_blogs
FOR ALL
USING (
    EXISTS (
        SELECT 1
        FROM pr_articles a
        JOIN pr_sessions s ON s.id = a.session_id
        WHERE a.id = pr_blogs.article_id
        AND s.user_id = auth.uid()
    )
)
WITH CHECK (
    EXISTS (
        SELECT 1
        FROM pr_articles a
        JOIN pr_sessions s ON s.id = a.session_id
        WHERE a.id = pr_blogs.article_id
        AND s.user_id = auth.uid()
    )
);

-- Create the admin/superadmin check function
CREATE OR REPLACE FUNCTION is_admin_or_superadmin() 
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM users
        WHERE id = auth.uid()
        AND role IN ('admin', 'superadmin')
    );
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;

-- Create the superadmin check function
CREATE OR REPLACE FUNCTION is_superadmin() 
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM users
        WHERE id = auth.uid()
        AND role = 'superadmin'
    );
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;

-- Add comments
COMMENT ON FUNCTION public.is_admin_or_superadmin() IS 'Checks if the currently authenticated user has admin or superadmin role';
